---------------------------------------------------------------------------------------------------------------------------------------------------
1. 메소드
---------------------------------------------------------------------------------------------------------------------------------------------------
>> 메소드
		이름 뒤에 소괄호
		단, 키워드(if, while, for 같은 애들) 뒤에 소괄호는 메소드가 아니다.

>> 메소드 선언 과정
		(1)리턴타입 (2)메소드명(자료형 (3)매개변수명,...){
				(4)실행할 문장;
				(5)return 리턴값;
		}

		(1) 리턴값이 있다면 리턴값의 자료형을 작성하고, 리턴 값이 없다면 비워놓지 않고 void를 작성한다.
		(2) 동사로 작성한다.(연필(매개변수)을 쓴다(메소드).)
		(3) 외부에서 전달받을 값이 있다면, 자료형과 순서에 맞게 선언해준다.
		(4) 생략이 가능하다. 메소드의 기능을 구현하는 로직을 작성한다.
		(5) 생략이 가능하다. 리턴값이 있다면, 사용한 부분을 통째로를 리턴값으로 봐야한다. 

>> 메소드 선언 예시
		E.g) 두 정수의 덧셈 메소드를 선언 

		1) 메소드 이름을 생각한다.
 			add(){} //메소드 뒤에는 소괄호!! 선언 뒤에 중괄호

		** 메소드 이름 명명 규칙**
			- 메소드 이름은 카멜표기법으로 작성
			- 메소드를 보고 의미를 파악할 수 있게 구체적으로 이름을 작성
			- 주로 동사로 작성

		2) 매개변수를 생각한다.
			add(int number1, int number2){} //매개변수는 받을 게 없으면 안써도 됨

		3) 실행할 문장을 작성한다.
			add(int number1, int number2) {
				int result=number1+number2;
			}

		4) 리턴 값을 작성한다. 
			add(int number1, int number2){
				int result=number1+number2;
				return result;
			}
		
		5) 리턴 타입을 결정한다.
			int add(int number1, int number2){
				int result=number1+number2;
				return result;
			}

>> 메소드 주의사항 
		1) 메소드를 선언할 때는 {}(중괄호)가 있으며, 반드시 메소드 밖에서 선언한다. 
		2) 메소드를 사용할 때는 {}(중괄호)가 없으며, 반드시 메소드 안에서 사용한다.

>> 메소드 목적
		1) 재사용
		2) 소스코드 간결화

---------------------------------------------------------------------------------------------------------------------------------------------------
2. 클래스
---------------------------------------------------------------------------------------------------------------------------------------------------
>> 클래스(반) 
		공통 요소를 한 번만 선언해놓고 가져다 사용만 하도록 설계한다.

		1) 타입
			클래스 안에 선언된 변수와 메소드를 사용하고 싶다면,	
			해당 클래스 타입으로 객체를 선언해야 한다.
			
		2) 주어	
			원숭이가 바나나를 먹는다.
			Monkey.eat("바나나");
			주어  동사  목적어

>> 클래스 선언
		class 클래스명{
			필드(변수, 메소드)
		}

>> 클래스의 필드 사용 ★
		객체화(instance): 객체(instance variable)를 만드는 작업, 추상적인 개념을 구체회시키는 작업.
				클래스명 객체 = new 생성자();
				객체.필드명

		※ .(마침표): 하위 연산자, 닷 연산자, 점 연산자, 멤버변수 접근 연산자	
		  		주소값 뒤에서만 사용이 가능하며, 해당 주소를 참조하는 명령어이다. 

---------------------------------------------------------------------------------------------------------------------------------------------------
3. 생성자
---------------------------------------------------------------------------------------------------------------------------------------------------
>> 생성자 (이미 리턴해야 할 값이 정해져 있는 것임!!)
		new 연산자로 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당한다. 
		클래스 이름 뒤에 소괄호가 있는 형태로 메소드와 기능이 똑같지만 메소드라고 부르지 않는다. 
		생성자는 리턴이라는 기능이 존재하지 않기 때문이다.
		-> 객체가 생성될 때 자동적으로 호출되는 특수한 목적을 지닌 메소드라고 생각하면 된다.

		1) 해당 클래스의 필드를 메모리에 할당한 후 부여된 주소값을 가져온다. (힙 영역에 객체 생성)
		2) 객체의 초기화 (필드를 초기화하거나 메소드를 호출해서 객체를 사용할 준비를 하는 것)

>> 생성자의 특징
		1) 생성자는 클래스 이름과 동일 
		2) 객체가 호출될 때 자동으로 한번 호출
 

>> 기본 생성자
		매개변수가 없는 생성자이며, 클래스 선언 시 자동으로 선언된다.
		사용자가 직접 생성자를 선언하게 되면 자동으로 생성자가 선언되지 않는다.

>> this
		필드에 접근한 객체가 누구인지 알아야 해당 필드에 접근할 수 있다. 
		이 때, 접근한 객체가 가지고 있는 필드의 주소값이 this라는 변수에 자동으로 담긴다. 
		--> 지역변수와 인스턴스 변수를 구별할 때 사용함

>> 생성자 this()
		생성자에서 다른 생성자를 호출할 때 사용
		생성자 코드의 중복을 줄이고 초기화 과정을 단순화하는 데 유용
